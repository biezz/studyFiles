一、Python开发相关
1、基础
列表：列表是python当中的一种数据结构类型，用[]来表示，可以存储任何对象的一个有序序列。
	example：[a,b,c,1,2,3]
	有序：可以通过索引取值，列表中从左至右每一项值对应的索引，是有序的。

	切片：a = ['a','b','c','d','e']	----->	a[1:3]=['b','c']


字典：用大括号"{}"包裹，以逗号分隔每个键值对，键与值之间用冒号连接。
	特点：字典是无序的，键值必须唯一，值可以是任何数据对象。
	example：{key:value} ----->	{1: 2, 3: 4, 5: 6}

	sorted遍历字典，遍历结果是右key组成的序列
	a = {1:'a',2:'b',3:'c',4:'d',5:'e'}  sorted(a) = [1,2,3,4,5]

元组：元组创建后不能修改，标识是逗号"," 不是括号
	a = (1,2) 等同于 a = 1,2

集合：一种无序不重复元素的序列。
	创建空集合：set() ，而非{}
	set(序列对象):将序列转化为集合
	集合运算：差集，交集，合集（-，&，|）

函数：函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。
	def 函数名（参数）
		do something
		return 值/对象/函数/表达式等

	规范：功能单一，抽象解耦
	单行尽量不超过80字符
	封装的函数尽量不超过50行

	分类：内建函数&&自定义函数

	函数参数：普通、默认参数、可变长参数
	默认参数：当没有提供参数时，此时函数调用默认参数。
	可变长参数：*args **kwargs 支持传递任何形式，任何长度的参数。

	可变长参数---函数式编程---嵌套函数---闭包---装饰器

类：把具有一类属性和行为的对象封装起来，放到一个类里，以对象的形式调用。
	类实例==类对象
	类里面所有函数第一个参数需要写成self
	-----------------------------------------------------------------------------
	class Person():	#如果需要继承父类，就在括号中填写父类名称，反之，可以省略括号

	  def __init__(self, age, gender, height, weight):   #类的初始化
        self.age = age
        self.gender = gender
        self.height = height
        self.weight = weight

     ming = person(20,'man',175，70)
	------------------------------------------------------------------------------
	类属性：不需要赋予对象就可以使用的属性
	类实例属性：需要赋予对象才能使用的属性

异常：try:
		  ...
	  except:
	  	  ...

	  异常组成：traceback信息 + 出错类型 + 出错原因
	  抛异常机制：看资料理解
	  如何处理异常,通过以下这种方式处理，是否展示异常信息：
	  --------------------------------------
	  import  traceback
	  print(str(traceback.format_exc()))
	  ---------------------------------------

2、高阶
列表推导式：用一句话完成列表遍历，把循环当中满足条件的项取出来
	格式一：[表达式 for xx in 序列 if 条件表达式]
	example：列出10以内的偶数	
	[x for x in range(0，10) if x%2 ==0]
	延伸：filter(function,sequence)可以实现类似功能

	格式二：[表达式 if 条件 else 表达式 for xx in 序列]
	example：10以内的奇数平方，偶数减半
	[x*x if x%2 ==1 else x/2 for x in range(0,10)]

深拷贝：循环遍历中删除问题
	思路：再拷贝一个对象，这个对象和原来的对象是2个内存地址，遍历新的对象，删除原来的对象。
	example：删除列表中的字符串的项

	---------------------------------------------------
	import copy

	input_list = [1,"ac",32,7,"test","123"]
	new_list = copy.deepcopy(input_list)

	for item in new_list:
    	if isinstance(item,str):
        	input_list.remove(item)
        
	print(input_list)
	---------------------------------------------------

函数式编程：对别的函数进行封装、运算、操作的函数。
	参数：支持传别的函数名 && 可变长参数
 	判断超时函数：
 	----------------------------------------------------
 	def handle_timeout(func, timeout, *args, **kwargs):
    interval = 1
    
    ret = None
    while timeout > 0:
        begin_time = time.time()
        ret = func(*args, **kwargs)
        if ret:
            break
        time.sleep(interval)
        timeout -= time.time() - begin_time
    
    return ret
    -----------------------------------------------------

   高阶函数：既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。

类变量：在内存静态存储区

匿名函数：lambda函数，形式一般是后面跟一个或多个参数，跟着冒号，然后是表达式
	lambda x , y : x + y
	-------------------------------------------------------------------------
	a = lambda x , y : x + y
	type(a)
	<class 'function'>
	a(9,3)
	3.0
	-------------------------------------------------------------------------

map用法：map (函数名，序列)
	example：求出1-10以内所有数的平方
	a = map(lambda x : x * x , range(1,10))
	list(a)
	[1, 4, 9, 16, 25, 36, 49, 64, 81]

filter用法：
	同map类似，把符合条件的元素筛选出来

sorted用法：sorted(iterable, key, reverse)
	用途：用于解决排名，排序问题
	reverse = True 时，实现从大到小排序
	sorted可以和lambda结合使用
	example：
	--------------------------------------------
	a = [1,9,23,8,5,11]
	sorted(a)
	[1, 5, 8, 9, 11, 23]
	sorted(a, reverse=True)
	[23, 11, 9, 8, 5, 1]

	------------------------------------------------

闭包：调用一个函数a,这个函数a返回了一个子函数名字b给你，这个返回的函数b就叫作闭包
	应用场景：装饰器

装饰器 等于闭包+函数式编程
	----------------------------------------------------------------
	#coding:utf-8
	import time

	def clac_time(func):

    	def calc(*args, **kwargs):
        	begin_time = time.time()
        	ret = func(*args, **kwargs)
       	 	print("花费时间：%s秒" % (time.time() - begin_time))
       	 	return ret

    	return calc

    @clac_time
    def eat_bf():
    	time.sleep(5)

    @clac_time
    def run():
    	time.sleep(3)

    @clac_time
    def watch_movie(movie_name):
    	print('电影名字：%s'%movie_name)
    	time.sleep(4)

    print('开始吃早餐')
    eat_bf()
    print('开始跑步')
    run()
    print('开始看电影')
    watch_movie('神奇女侠')
    ----------------------------------------------------------------------

 单例：单例是装饰器的一种

3、web框架（项目）

Tornado框架：
	异步性能，tornado的异步性能比较好，原因是tornado是单线程（主线程），如果让tornado去处理请求链接的内容，那么主线程会被占用，此时无法接受其他的请求，因此在封装的时候，，做成异步的方式，才能适应高并发的请求。
	异步接口：可以qps很高

	协程：执行到下一个入口点之前暂停，保存执行的状态，等到合适的时机恢复到执行状态，从下一个入口点重新开始执行，这也是协程应该具有的能力。这让tornado可以接收更多的访问请求。

	异步原理：主线程接收到请求，通过yield将主线程给解放出来
			 真正实现的耗时的部分放到线程池里去做
			 线程池在做完了操作之后通过通知主线程，主线程在完成http请求通知调者
			 整个过程主线程做的事：接受请求，返回请求。


Django框架：
做过一个简单的博客论坛，实现的功能有：web板块，文章列表，文章发布，文章详情，翻页功能，以及登录，登出和注册等。

各个框架的优缺点：
	tornado：中文文档少，异步性能高
	Django：中文丰富，开发速度快，耦合性高
	flask：文档也比较多，各方面处于两者之间


4、运维方面

监控工具：zabbix，cacti
自动化运维工具：ansible，puppet等
git使用以及工作原理
mysql高可用

5、可能会问到的问题？
用python开发过哪些工具？
做过哪些python项目？